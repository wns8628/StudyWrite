인덱스

기본용어 

 - 데이터베이스 

  데이터파일과 로그파일로 구성 
  데이터파일 : mdf, ndf 
  로그파일 : idf확장자 
  다양한 형태의 개체들을 포함 : 테이블, 익덱스,뷰,함수,트리거,프로시저 등등 

  		*테이블 : 우리의 데이터를가지고 물리적으로 저장되있다.

 
 
 쿼리문때리면(select) : 테이블로날라감 ? - 아님  인덱스로날라가게해야함

 페이지: 테이블에 데이터를 insert하게되면 그 행 ,그 레코드는 (8kb)페이지에
            들어오게됨 (쓰여짐)

           근데 페이지하나당 데이터가 10개있으면  100개읽으려면 페이지 10개읽어야함..
         
           이것이성능의 시작이다. --페이지를 잘 알아야한다. 

          즉 페이지내의 행이 많을수록 i/o효율증가

         0번부터 n사이의 순차적인 번호 페이지번호가있다.             

         
             
        
         100

 12    홍길동   ---  100번 페이지에 4개의 행이 포함되어있다.   한번읽을떄 4개읽는다.
 14    안경태   ---
 28    김치국   --- 
 27    오발탄   ---


---------------------
 - 인덱스는 주민센터(사람찾기), 도서검색시스템, 다리(강건너그곳에 가장빨리갈수있게)

 = 빨리빨리 

 인덱스의 장점 : 빠른데이터검색 

  - 찾는데이터를 가지고있다면 직접주거나 ,없다면 어디있는지 알려줌 

  - 데이터 중복방지 : pk , 유니크 제약 

  - 잠금 최소화 - 최소범위 잠금가능 , 동시성높여줌
                     = 즉 그부분만빨리 업데이트하고나오기때문에 동시성높여줌

  
  단점 

     -  물리적인공간차지 (테이블,인덱스 두개밖엥벗다 물리적으로저장되는건)
     -  인덱스는 테이블처럼 데이터를 가짐 -즉 페이지가있다
 
     - select는 인덱스좋아함 , insert문은 인덱스를 별로좋아하지않는다(전입신고해야함)
          
     
----------------------------------

 유지관리필요성

  - 인덱스는 전지전능x 

  - 인덱스 조각화문제(내부,외부) , 자동화? 
                                
 ------------------------------------------------------

 테이블의 존재형태 

  힙 형태이던지,  클러스터형 인덱스 형태이던지 	
		(정렬되있다)
                 <바꾸기> 


   비클러스터형 인덱스들의 도움을 필요로한다 = 정렬되있다.  이걸 추가하는거임 

 
 * 인덱스는 정렬되있는 데이터를 가지고있기때문에 빠르다

 ---
 힙 =  정렬되어 저장되지않은 테이블의 존재형태  - 행들간순서가없다
                                                                - 데이터 페이지들 간에도 순서없다.
                                                                *클러스터형 인덱스가 없는테이블이다

 즉 insert는 좋아함 빈공간에 다집어넣으면되니깐
    select는 싫어함 찾기힘드니깐 
-
 
클러스터형 인덱스  = 정렬되있다, 데이터를 가지고있다 = 강력
 
  이메일로정렬하고싶다 이메일 빼서 클러스터형걸어버리면된다????

   힙->클러스터형 = 힙은사라지고 다른곳에 클러스터형 인덱스가 생성됨 

      만들때 유니크속성 왠만하면줘라..

   
  만능이아니다 - a를기준으로 정렬되있지만 a=5인것 = 빠르지만
 
                                                          b=10 .. 이건어캐찾냐 시간오래걸린다  




    * 그래서 힙이든 클러스터형이든 = 비 클러스터형 인덱스가 필요하다. *


 
- Table scan -------------------------------------------------------

  데이터를 찾을수있는 유일한 방법
 
  모든페이지 다읽어야함, 참고:iam페이지를 참조해서 해당 데이터를 모두 읽게 됨 





---------------------------------------

 힙
 +
 비클러스터 형 인덱스 ( 데이터 + RID )
 
          예를들면 이메일데이터를 다들고있고 또 RID: 행의주소를가지고있다 .	
					  (몇번째줄,몇번째행 이런거)	
   					
         이메일다들고있는데 다른거요구하면 RID를통해서 찾아가라하는거지
 			
 
 데이터찾아가는거 = index Seek = 루트페이지부터 찾아가기  
   
                       
   클러스티드 인덱스 시크 = 앞에 없거나 클러스티드빠지면 다 non클러스티드임 

 
  RID Lookup = 찾아가는데 힙 에찾아가는거임(힙의 형태로 테이블을가지고잇다 ) 
 
  인덱스스캔 - 리프수준의 모든인덱스 페이지를 쫘악 읽음 
                    이테이블의 레코드총개수?구할때 = 이게더빨라서
   


  -----------------------------------

 클러스터 형 인덱스  (이미정렬되어있다.)
 +  
 비클러스터 형 인덱스 ( 데이터 + 클러스터 형 키열? ) 

 
---

힙 + 넌클 =  인덱스 키값 + RID ,

클러스터+넌클 = 인덱스 키값 + 클러스터형 인덱스 키값 


-------------------------------------
알품인

 즉 힙의 A열에 인덱스걸면 

 넌클러인덱스에는 A열의 모든데이터와 RID가걸린다


-----------------------
키품인

 클러스터형인덱스(c에 클러스터가걸려잇다, c로정렬되어있다.)의
  A열에 인덱스를걸면(A에다 넌클러스트를만든다) 

 넌클러 인덱스는 A,C 가 들어간다  
  
 
커버드 쿼리 = 데이터까지안가고 데이터 찾아옴


--

걸수있는거?  15개 900kb?   
 
 많이걸면 테이블과 다를게없잔아.. 욕심내지마 

------------
 

 1. Non-clustered Index : 인덱스의 데이터가 테이블의 데이터 영역과 구별된 독립적인 영역에 존재하는 인덱스.

넌클러스터드 인덱스는 우리가 흔히 알고있는 인덱스의 구조를 갖는다.

인덱스는 아래 그림과 같이 Root, Intermediate, Leaf의 세 영역으로 구분되는 구조를 갖는데,

Root부터 Leaf 레벨까지 모든 인덱스데이터가 데이터 영역이 아닌 별도의 영역에 만들어지게 된다.

즉, 테이블 데이터가 직접 정렬되는 것이 아니고 별도의 데이터가 생성되어 정렬되는 것이므로 넌클러스터드 인덱스는 복수로 생성이 가능하다.


 

==========
다시정리 


 회사에 테이블10개 클러스터인덱스 10개 ? 

 고객의 테이블이 이름으로 정렬되어있는데 이메일로정렬하고싶다 - 방법이없네 ..
 (이름으로정렬된 클러스터가있으니)
  ↓
 이메일을 다른테이블로 빼서 클러스터 걸어버리면됨?     
                    
  결국 테이블의 존재형태 = 힙 or 클러스터형인덱스 -반반없다. 
 
특정회사? 
 100개중 30개만 클러스터드 = 이유 ?몰라시발  

 
  근데 둘다(힙,클러스터) 데이터가많다면 ? = 풀스캔? 에바임
  물론 정렬되있는 클러스터를 읽는게 더좋긴하겠지만 쨋든 둘다 다읽으면 좀 그래..

  그래서 scan 보다는 seek가 최고

**
 인덱스의 구조 - 나무를 뒤집은형태 
    
           [루트페이지]             Index Level 3 
                |
 	[ ]  [ ]  [ ]               Index Level 2(Intermediate Level)      
        	    |
        [ ] [ ] [ ] [ ] [ ] 	   Index Level 1(Intermediate Level)  
	    |
[ first Page] [ ] [ ] [ ] [ ] [ ]      Index Level 0(Leaf Level)
   


*인덱스 만들때  UNIQUE (유니크 유일성) 걸어줘야함 
왜냐 이테이블은 중복된데이터가 없어요! 말해야하니깐
안걸어주면 아니면 클러스터가 내부적으로 유일성 확보를위해 필드하나를더만든다 즉 공간낭비임 


 클러스터는 만능이아니다. - 

   A열을 기준으로 정렬된 데이터= A로만찾는다면 날라다님 = seek? 
   근데 B,C로 찾는다면 ??? = seek가아닌 scan해야함 


---------------------------------
 힙 + 비클러스터형인덱스

그래서 나온게 힙 + 비클러스터형인덱스이다. 

  즉 where절에 B,C가 많이 언급된다. = B,C에다가 비클러스터형인덱스를 만들면됨

  C에다가 걸면 비클러스터형인덱스는 C의 데이터를 전부가지고있고 RID를 가진다.
	- C의 모든 데이터	 
	- RID(행의주소)

			[ 루트페이지 ]

		      필드                 RID 
                         [  c의데이터   |  MDF:페이지:몇번쨰  ]
  

 RID를 갖는이유 = 주소를 딱 찍어줌 몇번째 페이지의 몇번째에있다. ( ***즉 힙을찾아가는거임)

 힙 + 비클러스터형인덱스 

---------------

 딱딱 = seek 
       = RID Lookup 
       

데이터찾아가기 
 	↘
	 index seek 라고함 (앞에 클러스터, 넌클러스터빠지면 = 넌클러스터인덱스임)	
 	 (클러스터 인덱스시크면  'clustered index seek' 라고나옴)
  
ex)
  실행결과를 봤더니?  index seek 나옴 => 이테이블은 클러스터인덱스가없네? 이렇게나와야함 
 
  실행결과를 봤더니? RID Lookup? = > 힙찾아가는거임 
					↘
				루트페이지 -> 비클러스티드인덱스찾아가는거 index seek
				비클러스티드인덱스에서 힙찾아가는거 RID Lookup    


 즉 회사에서 쿼리돌려서  RID Lookup 나오면 힙 형태의 테이블을 가지고있다는거고 
     회사에 전부다 테이블이 클러스티드형이면 절대로  RID Lookup을 볼수없겠지...


 비클러스터인덱스가 C데이터와 RID를 가지고있을때
 사용자가 D를원한다? = RID가지고 찾아가라하면됨.

 
 index scan  = 리프수준의 모든인덱스페이지를 쫘악읽는다. - 즉위에선 비클러스티드인덱스페이지 를다읽는거지
 	       index seek보단느리고 테이블스캔보단 당연빠르지
		↘
		  이테이블 레코드개수는뭐냐 - 인덱스스캔이빠름
 
                     즉 넌클러스티드인덱스가 있다면! 카운터구하는것도빠르다 근데 없으면
		테이블스캔해야하니 느리지
	     

-----------------------
  
 자이제 클러스터 형 인덱스 + 비 클러스터형 인덱스를 알아보자

   상황이달라진다.

 이름으로 정렬된 전화번호부가있다 - > 클러스터 인덱스죠 

 물어보면 = 저전화번호부의 100번쨰 페이지의 5번째줄에 누구누구가있어요 이럴거임 ? ㄴㄴ 
    ↘
 저건 이름으로 정렬되어있으니 잘찾아보이소 - GOOD  즉 주소를안찍어줘도됨 

 즉 RID를 안가르쳐줘도됨 ( RID넣어도되는데 문제는 정렬이라는것이다 중간에낑기면 RID를 전부다바꿔줘야함 ㅅㅂ..)
  
 그래서 RID대신에 인덱스Key값을가짐  
 
ex)
 A테이블이 번호 ,이름 등등을 가진테이블이고 클러스터형이고 클러스터는 이름에걸려있다고하면 = 클러스터지 
   
비클러스터인덱스는
 [ A의모든번호데이터 | 인덱스 키값 ]  을가짐
                            (이름에클러스터니깐 이름이지 ) 


 즉  비클러스터인덱스의 루트페이지 -> 비클러스터   = index Seek 
      
      비클러스터-> 클러스터인덱스 = key lookup
      
       클러스터인덱스의 루트페이지 -> 클러스터인덱스데이터찾아가기 = Clustered index Seek
           
      
 key lookup은 비클러스터형인덱스가 가지지못한 데이터를 찾아가는 과정이다.
  
-----------------


 ABCD 
   A = 비클러  
   B =  비클러
   C = 클러스터키값
   D = 클러스터키값
 
 select C,D FROM 테이블 WHERE A=1,B=2 인거 = 최고다. // 커버드쿼리를 만들자 

키컬럼 제한 

 15개 900바이트 

결론 쿼리를 테이블이 아닌 인덱스로 날려라!


================================================================================================================



처음에 이름검색이 기본이니 

 이름을 검색 = >  직원이름에 클러스터인덱스걸면 금방찾겠지- 거기서 부서찾기ㄱ 

                        no,grade, name,age,gender, departments_no
						↘
					    	여기서 한번더 들어가야함 
		
		근데 departments_no는 fk라서 
		부서테이블이 no로 정렬되어있음
				     ?? 안걸어도됨



레코드가작으면 8kb 페이지를 1000개읽어야하는걸 10개만읽으면됨  = 즉 작은레코드를가진 테이블을 읽게하는게 훠얼씬효율적이다.







